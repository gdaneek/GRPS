#pragma once


/**
 * \file memory_part.hpp
 * contains a class that simulates real memory
 * intermediate memory representation for a graphical application,
 * generated by TMP FSM
 */

#include <vector>
#include <cstdlib>
#include <ctime>

using address_t = uint32_t; //<  data type that should be considered as a memory address

/**
* A unit for building a MemoryPart
*/
struct MemoryByte {
    address_t addr;
    uint8_t value;
    std::string name;
    bool is_pointer;
};

/**
* a part of the memory showing how the transferred tokens are stored
*/
class MemoryPart : public std::vector<MemoryByte> {

    address_t start_addr;
public:

    MemoryPart() : std::vector<MemoryByte>{} {
        std::srand(std::time(0));
        start_addr = 0x7ff000000000 + (std::rand() % (long)1e5);
    }

    address_t align_addr(const uint8_t mod) {
        while(start_addr % mod)
            this->push_back(MemoryByte{start_addr++, (uint8_t)std::rand(), "", false});

        return start_addr;
    }

    template<typename T>
    address_t push_bytes(const std::string& name, T value, const uint8_t bytes_num, const bool is_ptr = false) {
        auto binded_addr {align_addr(bytes_num)};
        for(auto i{0};i < bytes_num; ++i)   // MSB order
            this->push_back(MemoryByte{start_addr++, (uint8_t)(value >> ((bytes_num-i-1) << 3)), name, is_ptr});

        return binded_addr;
    }

}; // MemoryPart


